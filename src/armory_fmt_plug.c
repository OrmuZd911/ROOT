/*
 * This file is part of John the Ripper password cracker,
 * Copyright (c) 2024 by Solar Designer
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted.
 *
 * There's ABSOLUTELY NO WARRANTY, express or implied.
 */

#if FMT_EXTERNS_H
extern struct fmt_main fmt_armory;
#elif FMT_REGISTERS_H
john_register_one(&fmt_armory);
#else

#include <stdint.h>
#include <string.h>

#include "base64_convert.h"
#include "formats.h"
#include "memory.h"
#include "crc32.h"
#include "sha2.h"
#include "aes.h"
#include "secp256k1.h"
#include "sph_ripemd.h"

#define FORMAT_LABEL			"armory"
#define FORMAT_TAG			"YXI6"
#define FORMAT_TAG_LEN			(sizeof(FORMAT_TAG) - 1)
#define FORMAT_NAME			"Armory wallet"
#define ALGORITHM_NAME			"SHA-512/AES-256/secp256k1/SHA-256/RIPEMD-160"

#define BENCHMARK_COMMENT		""
#define BENCHMARK_LENGTH		0x107

#define PLAINTEXT_LENGTH		125
#define CIPHERTEXT_LENGTH		156

struct custom_salt {
	uint8_t privkey[32], iv[16];
	uint32_t bytes_reqd, iter_count;
	uint8_t seed[32];
	uint32_t crc;
};

#define BINARY_SIZE			20
#define BINARY_ALIGN			1
#define SALT_SIZE			sizeof(struct custom_salt)
#define SALT_ALIGN			sizeof(uint32_t)

#define MIN_KEYS_PER_CRYPT		1
#define MAX_KEYS_PER_CRYPT		1

/*
 * These test vectors were extracted from test wallets by Christopher Gurnee's
 * btcrecover/extract-scripts/extract-armory-privkey.py
 */
static struct fmt_tests tests[] = {
	/* 2 MiB, 4 iterations */
	{"YXI6r7mks1qvph4G+rRT7WlIptdr9qDqyFTfXNJ3ciuWJ12BgWX5Il+y28hLNr/u4Wl49hUi4JBeq6Jz9dVBX3vAJ6476FEAACAABAAAAGGwnwXRpPbBzC5lCOBVVWDu7mUJetBOBvzVAv0IbrboDXqA8A==", "btcr-test-password"},
	/* 4 MiB, 6 iterations, generated by Armory 0.95.1 */
	{"YXI6uOgnVa0B+Wx63/haI5oBRHkDf7ge3Kjc5LXnYXtnlIUHDD+J3u5ilyHfMmo7uaFaj1cbogHyjdZUhZj3a6XzdFE3NA0AAEAABgAAAARJgevrWUGCq2+5j8v3ei+vkZOpcUhdPDwrKTyXAU4znXCL2A==", "jtr-test-password"},
	/* 32 MiB, 3 iterations */
	{"YXI6q0bSuS3K6msHGDI5wSvD04RH7VqENEsIctti29xVGbyxLoqwIyGL53+qFOkW1Zqb6ZncatQZgX/3cf9XXxjFbSxGp4EAAAACAwAAAKKiUt8yakXdpwZ6SnbPFbwIsUzUUVMgwlySR02FFtMijFRpew==", "a3q92wz8"},
	{NULL}
};

static char saved_key[MAX_KEYS_PER_CRYPT][PLAINTEXT_LENGTH + 1];
static struct custom_salt *saved_salt;
static uint8_t crypt_out[BINARY_SIZE];

static void *get_salt(char *ciphertext)
{
	uint8_t decoded[BINARY_SIZE + SALT_SIZE];
	int err;

	ciphertext += FORMAT_TAG_LEN;
	if (base64_convert(ciphertext, e_b64_mime, strlen(ciphertext),
	    decoded, e_b64_raw, sizeof(decoded), flg_Base64_DONOT_NULL_TERMINATE, &err) != sizeof(decoded) || err)
		return NULL;

	/* XXX add endianness conversion */
	static struct custom_salt salt;
	memcpy(&salt, &decoded[BINARY_SIZE], sizeof(salt));

	if ((salt.bytes_reqd & 63) || salt.bytes_reqd < 128)
		return NULL;

	CRC32_t crc;
	CRC32_Init(&crc);
	CRC32_Update(&crc, "ar:", 3);
	CRC32_Update(&crc, decoded, sizeof(decoded) - sizeof(salt.crc));
	if (salt.crc != ~crc)
		return NULL;

	return &salt;
}

static void *get_binary(char *ciphertext)
{
	static uint8_t binary[BINARY_SIZE];
	int err;

	ciphertext += FORMAT_TAG_LEN;
	if (base64_convert(ciphertext, e_b64_mime, strlen(ciphertext),
	    binary, e_b64_raw, sizeof(binary), flg_Base64_DONOT_NULL_TERMINATE, &err) != sizeof(binary) || err)
		return NULL;

	return binary;
}

static int valid(char *ciphertext, struct fmt_main *self)
{
	if (strncmp(ciphertext, FORMAT_TAG, FORMAT_TAG_LEN) || strlen(ciphertext) != CIPHERTEXT_LENGTH)
		return 0;

	return get_salt(ciphertext) != NULL;
}

static void set_salt(void *salt)
{
	saved_salt = salt;
}

static void set_key(char *key, int index)
{
	char *p = saved_key[index];
	*p = 0;
	strncat(p, key, PLAINTEXT_LENGTH);
}

static char *get_key(int index)
{
	return saved_key[index];
}

static void derive_key(char *key, const struct custom_salt *salt, uint8_t *dk)
{
	static uint64_t (*lut)[8];
	static uint32_t lut_size;
	uint32_t i, n;

	if (!lut || lut_size < salt->bytes_reqd) {
		MEM_FREE(lut);
		lut = mem_alloc(lut_size = salt->bytes_reqd);
		/* XXX free this memory in done() */
	}

	uint8_t *mk = (uint8_t *)key;
	size_t mklen = strlen(key);

	n = salt->bytes_reqd >> 6;
	i = salt->iter_count;
	do {
		uint64_t (*p)[8];
		SHA512_CTX ctx;

		SHA512_Init(&ctx);
		SHA512_Update(&ctx, mk, mklen);
		SHA512_Update(&ctx, salt->seed, sizeof(salt->seed));
		SHA512_Final((unsigned char *)lut, &ctx);

		p = lut;
		do {
			SHA512_Init(&ctx);
			SHA512_Update(&ctx, p, 64);
			SHA512_Final((unsigned char *)++p, &ctx);
		} while (p < &lut[n - 1]);

		uint64_t x[8];
		memcpy(x, p, sizeof(x));

		uint32_t j = n >> 1;
		do {
			p = &lut[(x[7] >> 32) % n]; /* XXX: endianness */

			uint32_t k;
			for (k = 0; k < 8; k++)
				x[k] ^= (*p)[k];

			SHA512_Init(&ctx);
			SHA512_Update(&ctx, x, 64);
			SHA512_Final((unsigned char *)x, &ctx);
		} while (--j);

		memcpy(mk = dk, x, mklen = 32);
	} while (--i);
}

static int crypt_all(int *pcount, struct db_salt *salt)
{
	union {
		uint8_t u8[32];
		uint64_t u64[4];
	} dk;

	/* Derive AES key */
	derive_key(saved_key[0], saved_salt, dk.u8);

	/* AES CFB mode decryption */
	AES_KEY ak;
	AES_set_encrypt_key(dk.u8, 256, &ak);
	AES_encrypt(saved_salt->iv, dk.u8, &ak);
	uint64_t xor[2];
	memcpy(xor, saved_salt->privkey, sizeof(xor));
	dk.u64[0] ^= xor[0];
	dk.u64[1] ^= xor[1];
	AES_encrypt(saved_salt->privkey, &dk.u8[16], &ak);
	memcpy(xor, saved_salt->privkey + 16, sizeof(xor));
	dk.u64[2] ^= xor[0];
	dk.u64[3] ^= xor[1];

	secp256k1_pubkey pubkey;
	static secp256k1_context *sctx;
	if (!sctx)
		sctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN); /* XXX destroy this in done() */

	/* Compute public key from decrypted private key */
	if (secp256k1_ec_pubkey_create(sctx, &pubkey, dk.u8)) {
		unsigned char ser[65];
		size_t serlen = sizeof(ser);
		secp256k1_ec_pubkey_serialize(sctx, ser, &serlen, &pubkey, SECP256K1_EC_UNCOMPRESSED);

		/* Hash160 */
		{
			SHA256_CTX ctx;
			SHA256_Init(&ctx);
			SHA256_Update(&ctx, ser, sizeof(ser));
			SHA256_Final(dk.u8, &ctx);
		}
		{
			sph_ripemd160_context ctx;
			sph_ripemd160_init(&ctx);
			sph_ripemd160(&ctx, dk.u8, 32);
			sph_ripemd160_close(&ctx, crypt_out);
		}
	} else {
		memset(crypt_out, 0, sizeof(crypt_out));
	}

	return *pcount;
}

static int cmp_all(void *binary, int count)
{
	return 1;
}

static int cmp_one(void *binary, int index)
{
	return !memcmp(binary, crypt_out, sizeof(crypt_out));
}

static int cmp_exact(char *source, int index)
{
	return 1;
}

struct fmt_main fmt_armory = {
	{
		FORMAT_LABEL,
		FORMAT_NAME,
		ALGORITHM_NAME,
		BENCHMARK_COMMENT,
		BENCHMARK_LENGTH,
		0,
		PLAINTEXT_LENGTH,
		BINARY_SIZE,
		BINARY_ALIGN,
		SALT_SIZE,
		SALT_ALIGN,
		MIN_KEYS_PER_CRYPT,
		MAX_KEYS_PER_CRYPT,
		FMT_CASE | FMT_8_BIT,
		{ NULL },
		{ FORMAT_TAG },
		tests
	}, {
		fmt_default_init,
		fmt_default_done,
		fmt_default_reset,
		fmt_default_prepare,
		valid,
		fmt_default_split,
		get_binary,
		get_salt,
		{ NULL },
		fmt_default_source,
		{
			fmt_default_binary_hash
		},
		fmt_default_salt_hash,
		NULL,
		set_salt,
		set_key,
		get_key,
		fmt_default_clear_keys,
		crypt_all,
		{
			fmt_default_get_hash
		},
		cmp_all,
		cmp_one,
		cmp_exact
	}
};

#endif /* plugin stanza */
